#ifndef LOCALPLANNERNOCVAR_H
#define LOCALPLANNERNOCVAR_H

#include "LocalPlanner.h"

class LocalPlannerNoCVar
{
public:
    LocalPlannerNoCVar();
    /// Initializes the LocalProblem structu which is passed in using the given parameters
    bool InitializeLocalProblem(LocalProblem& problem,  //< The local problem struct which will be fixed
                                const double dStartTime, //< Starting time of the problem, this is used to parametrized the generated command laws
                                const VelocityProfile* pVelProfile  = NULL,
                                LocalProblemCostMode eCostMode = eCostPoint);
    /// Given a LocalProblem struct which contains a velocity profile, this function obtains the corresponding
    /// acceleration profile based
    void _GetAccelerationProfile(LocalProblem& problem) const;
    /// Iterate the given problem using gauss-newton
    bool Iterate(LocalProblem &problem);
    /// Samples the 2D control law that is generated by solving the boundary value problem
    void SamplePath(const LocalProblem &problem, Eigen::Vector3dAlignedVec &vSamples, bool bBestSolution = false);
    /// Given the local problem struct, will simulate the vehicle physics and produce a motion sample
    Eigen::Vector6d SimulateTrajectory(MotionSample& sample,     //< The motion sample which will be filled by the function
                                      LocalProblem& problem,    //< The Local Problem structure which will define the trajectory
                                      const int nIndex = 0      //< The index of the world to run the simulation in (this is to do with the thread)
                                      , const bool &bBestSolution = false);
    /// Samples the acceleration and curvature of the current control law
    void SampleAcceleration(std::vector<ControlCommand>& vCommands, LocalProblem &problem) const;
    void StressTest(LocalProblem &problem);
    void CalculateTorqueCoefficients(LocalProblem &problem, MotionSample *pSample);
    /// Calculates the error for the current trajectory. The error is parametrized as [x,y,t,v]
    Eigen::VectorXd _CalculateSampleError(LocalProblem& problem, double& dMinTrajTime) const { return _CalculateSampleError(problem.m_CurrentSolution.m_Sample,problem,dMinTrajTime); }
    Eigen::VectorXd _CalculateSampleError(const MotionSample &sample, LocalProblem &problem, double &dMinTrajTime) const;
    Eigen::VectorXd _GetWeightVector(const LocalProblem& problem);
    double _CalculateErrorNorm(const LocalProblem &problem, const Eigen::VectorXd& dError);
    static int GetNumWorldsRequired(const int nOptParams) { return nOptParams*2+2;}
private:
    /// Calculates the jacobian of the trajectory at the current point in the trajectory
    bool _CalculateJacobian(LocalProblem &problem,          //< The problem struct defining the current trajectory and goals
                              Eigen::VectorXd& dCurrentErrorVec,          //< This is the current error vector
                              LocalProblemSolution& coordinateDescent,
                              Eigen::MatrixXd &J                    //< Output: The jacobian matrix
                              );
    /// Internal function that iterates the gauss-newton optimization step
    bool _IterateGaussNewton( LocalProblem& problem );

    /// Calculates the distance travelled, given the time passed
    double _DistanceTraveled( const double& t,const AccelerationProfile& profile ) const;

    /// Transforms the goal pose so that it is on the 2D manifold specified by the problem struct
    Eigen::Vector6d _TransformGoalPose(const Eigen::Vector6d &dGoalPose, const LocalProblem& problem) const;
    /// Returns the trajectory error given the trajectory and a transformed trajectory and end pose
    Eigen::VectorXd _GetTrajectoryError(const MotionSample& sample, const Eigen::Vector6dAlignedVec& vTransformedPoses, const Eigen::Vector6d& endPose, double &dMinTime) const;
    /// Transforms a vehicle state so that it is on the 2D manifold specified by the problem struct
    Eigen::Vector6d _Transform3dGoalPose(const VehicleState& state, const LocalProblem &problem) const;

    //boost::threadpool::pool m_ThreadPool;                       //< Threadpool for multitasking in jacobians and damping calculation
    double m_dEps;                                              //< The epsilon used in the calculation of the finite difference jacobian


    BezierBoundarySolver m_BoundarySolver;                      //< The boundary value problem solver

    Eigen::MatrixXd m_dPointWeight;                                       //< The matrix which holds the weighted Gauss-Newton weights
    Eigen::MatrixXd m_dTrajWeight;
    int m_nPlanCounter;
};

#endif // LOCALPLANNERNOCVAR_H
